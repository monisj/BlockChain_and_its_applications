Revision of Week 1.
Private Key is -
Public Key is +

Consider A with + - Keys
Consider B with + - keys

A sends a message with + keys
B receives message
B can decrypt message with its - keys

Now in this analogy any one can receive the message but it would be useless as its encrypted with A's + key

To preserve integrity (as man in the middle attack is prone) we utilize digital signature (signing).

A server is utilized with public keys stored in it for all nodes. (Refer to Assignment of Week 1)

What is a Hash Pointer?
1. Pointer to where data is stored and (cryptographic) hash of the info.
2. If we have a Hash we can ask for information and verify if its immutable (unchanged)

Answer from GPT:
A Hash Pointer is a pointer to a block of data, coupled with a cryptographic hash of that data. It combines both the address and the content integrity verification of the data it points to.

Key Components of a Hash Pointer:
Pointer: Points to the memory or location where the data is stored.
Hash: A cryptographic hash (e.g., SHA-256) of the data pointed to, which ensures that any alteration of the data can be detected.
How It Works:
If data at the location changes, the hash pointer's hash value will no longer match the recalculated hash of the current data.
This discrepancy allows you to detect tampering or unauthorized changes to the data.
Uses of Hash Pointer:
Blockchain and Cryptographic Systems:
In blockchains, each block contains a hash pointer to the previous block, forming a secure, tamper-proof chain of blocks.
Merkle Trees:
Nodes in a Merkle tree store hash pointers, enabling efficient and secure verification of data.
Immutable Data Structures:
Hash pointers are used to create immutable, secure data structures where past states of data can be verified without direct storage.
Example in a Blockchain:
Block n contains a hash pointer to block n-1. If an attacker tries to modify block n-1, the hash pointer in block n will no longer match, indicating tampering. This provides blockchain's immutability and security.

		(Hash of Data 2)
		--------------->
Prev| Data 1| Next  ->  |Prev| Data 2 |Next
	^-------------------------
		(Hash of Data 1)

For Hash We can use any algorithm (I'm considering SHA-256).
Doing this way we can guaranteed that the data in a particular node of a linked list cannot change.
Why? Well different nodes have different Hash pointers and changing the value would change the pointer.
With a simple if condition to check the old hash pointer with the current Hash Pointer would result in restriction, as a different Hash would destroy the linked list structure as many nodes are dependent on each nodes hash.

This is called Tamper-evident log. (Refer to slide 27 Lecture 3-4-5)

This sound bulletproof but there are some challenges that we would have to overcome.
Linked lists are a common data structure in data engineering, as they allow for dynamic and flexible insertion and deletion of elements. However, they also have some drawbacks, such asÂ slow access and traversal, memory overhead, and potential fragmentation (Taken from slide).

So linked lists are bad what about other data structures?
How about Binary Trees?

Answer: Yes there is a concept called Merkle Tree
A Merkle Tree (or hash tree) is a data structure used in cryptography and computer science to efficiently and securely verify the integrity and consistency of large data sets. It is a binary tree where each leaf node contains a hash of a data block, and each non-leaf node contains a hash of its child nodes.

Structure of a Merkle Tree:
Leaf Nodes: These contain the cryptographic hashes of the actual data blocks.
Non-Leaf Nodes: Each node contains the hash of its two child nodes.
Root Node (Merkle Root): The top-most node in the tree. It summarizes and uniquely represents the entire dataset. Any change in any part of the data will result in a completely different Merkle root.

How It Works:
Data blocks are hashed to create leaf nodes.
Pairs of leaf nodes are hashed together to form parent nodes.
This process continues upward until a single Merkle root is obtained.
If any data block changes, the hashes propagate up the tree, altering the Merkle root and enabling efficient detection of tampering.

Some Layout 

  	Merkle Root
           /    \
        Hash A   Hash B
        /   \     /   \
     Data1 Data2 Data3 Data4

Note that the pointers for left and right are now replaced by Hash pointers generated by data for each node.
Once again this is immutable as each node has a different hash and changing it would disrupt the flow of the binary tree. 

But you might ask if the data is large (many nodes) won't this make many parent nodes and with many parents node how would it traverse to its data node (assuming) that a data node has three parent nodes.

There is a concept called proof of membership.
In blockchain, a proof of membership is used in scenarios where you need to verify that a specific transaction, record, or data point exists in a block without downloading or exposing the entire blockchain. This ensures efficiency, privacy, and integrity of the data.

In a nutshell a Node would allow an entity if the Hash matches regardless if it has many nodes connected to it. The system would automatically route the entity to where ever the data node exist as long as the hash of that data exists and is in the system.

OK lets discuss about Block structure and Blockchains
(Refer to slide 35-37 Lecture 3-4-5)
